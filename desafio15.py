# -*- coding: utf-8 -*-
"""Desafio15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Dc60zVpUPusL6aEOKTBq0kesY_78HUUO
"""

using Base.Threads   # Importa funcionalidades de multithreading

println("Número de threads: ", nthreads())  # Mostra quantos threads Julia está usando

# Define o tamanho do loop (50 milhões de iterações)
N = 50_000_000


############################################################
#        EXECUÇÃO EM SÉRIE (APENAS 1 THREAD)
############################################################

println("\n--- Execução em série ---")

@time begin                    # Mede o tempo de execução do bloco
    s = 0.0                    # Acumulador que guardará a soma final

    # Loop comum (não-paralelo)
    for i in 1:N
        s += sqrt(i)           # Faz uma conta simples para simular cálculo pesado
    end

    println("Resultado (série): ", s)
end



############################################################
#     EXECUÇÃO EM PARALELO (VÁRIOS THREADS)
############################################################

println("\n--- Execução em paralelo ---")

@time begin

    # Vetor que armazenará a soma parcial de cada thread
    partial = zeros(Float64, nthreads())
    # Exemplo: se houver 8 threads → partial = [0,0,0,0,0,0,0,0]

    # Loop paralelo: Julia divide automaticamente as iterações entre os threads
    @threads for i in 1:N
        tid = threadid()              # Identifica qual thread está executando
        partial[tid] += sqrt(i)       # Cada thread acumula em seu próprio slot
    end

    # Soma de todas as partes calculadas pelos threads
    s_parallel = sum(partial)

    println("Resultado (paralelo): ", s_parallel)
end